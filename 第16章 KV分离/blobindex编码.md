KV分离的实现中，最本质的编码方式就是把原来value部分的数据offload到一个blob文件，同时使用一个blobindex来指向这个文件.

同时考虑历史和blob结合ttl的原因。有下面三种不同的编码方式：

```c++
enum class Type : unsigned char {
  kInlinedTTL = 0,
  kBlob = 1,
  kBlobTTL = 2,
  kUnknown = 3,
};
```

对于第一种inline ttl正如其字面意思：就是在value中指明expire 过期时间, 编码格式如下：

//    kInlinedTTL:
//      +------+------------+---------------+
//      | type | expiration | value         |
//      +------+------------+---------------+
//      | char | varint64   | variable size |
//      +------+------------+---------------+

第一个字段用来表明这种编码类型的本身，一个字节。第二个字段是一个过期时间戳8个字节。第三个字段实际的value值

对于blob类型：第一个字段是类型（其他的都类似）， 第二个字段是offload的文件号，第三个是文件的偏移地址，第四个是偏移后的数据大小
第五个是在这个地方的数据的编码方式， 方便我们从（file_number, offset, size) 读取文件信息后，使用压缩的类型来解压
//    kBlob:
//      +------+-------------+----------+----------+-------------+
//      | type | file number | offset   | size     | compression |
//      +------+-------------+----------+----------+-------------+
//      | char | varint64    | varint64 | varint64 | char        |
//      +------+-------------+----------+----------+-------------+

而kBlobTTL的编码方式, 只是在前面添加了一个8自己的过期时间。仅此而已
//    kBlobTTL:
//      +------+------------+-------------+----------+----------+-------------+
//      | type | expiration | file number | offset   | size     | compression |
//      +------+------------+-------------+----------+----------+-------------+
//      | char | varint64   | varint64    | varint64 | varint64 | char        |
//      +------+------------+-------------+----------+----------+-------------+

我们都知道在RocksDB中文件的压缩是按照层级可配置的。因为在compaction的过程中一个blob文件不一定总是对应一个level的sst文件。
同时，kv分离后，逻辑层是没有变化的。为了维护对每个逻辑层实现不同的压缩算法。故而要在BlobIndex中多添加一个字节的编码。来表名对应的kv的编码方式
而这个编码方式就是从LSM树上配置的压缩方式来的。
