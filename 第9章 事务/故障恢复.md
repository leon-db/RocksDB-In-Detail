# 故障恢复

    故障恢复是数据库保留原子性和持久性的基本技术手段（ACID中的A和D）。
在RocksDB中，数据的故障恢复的过程基本调用栈如下：

     1.  DB::Open
     2.  DBImpl::Recover
     3.  VersionSet::Recover

比如我们打印一个程序调用栈如下截图：

   ![Recover调用栈](./images/recover_stack.jpg)

## blob文件存储到version的过程
  对于之前老版本的blobdb kv分离的实现，默认是不track blob文件的。因此该版本的kv分离
  实现在发生故障的时候，没有办法保证数据的可恢复性。

  要做到数据的可恢复性，我们必须在日志中追踪每个根据的变更过程，
  这个机制目前主要是通过VersionEdit来实现。之所有使用这种机制，原理
  类似于Innodb中的 double write buffer。 当我们在做compaction的时候
  我们没有办法来保证文件操作的原子性。故而通过把文件的变动先临时保存在manifest文件中
  当所有的文件操作成功后，我们原子的切换该manifest文件，联动WAL日志，这样可以正确的做到
  原子性。
  
### 一个blob文件添加的全过程
  先看接口
  ```c++
  Status VersionSet::LogAndApply(ColumnFamilyData* column_family_data,
                                 const MutableCFOptions& mutable_cf_options,
                                 const autovector<VersionEdit*>& edit_list,
                                 InstrumentedMutex* mu, Directory* db_directory,
                                 bool new_descriptor_log,
                                 const ColumnFamilyOptions* new_cf_options)
```
  可以看到，我们的版本迭代变更是通过，应用（apply)一个个的VersionEdit来实现的。当然在这个实现的过程中
  可能会考虑效率的原因，使用组提交等相关技术。（类似于WAL写入时候的write_batch合并）
  
  下面我们详细的分析应用一个VersionEdit的过程。
  这个过程在RocksDB的整个实现过程中，非常的重要。从故障恢复（Recovery）,到我们的flush和compaction
  实现，基本上都离不开这个核心流程。


  在详细的介绍这个接口的实现的过程中，我们有必要补充一些基本的知识。如之前描述，Recover、flush和compaction等过程
都要依赖这个操作。我们都知道RocksDB源自LevelDB,只是在LevelDB的基础上添加了Column Family。
这个抽象的好处，大致是：
    1. 对于不同的数据可以做到比较好的隔离
    2. 相同类型的数据放在一个Cf中管理会更加的高效，比如说压缩等
因此在RocksDB的很多接口中都会隐含接口的操作单位为一个个的Column Family. 这个接口也不例外，它的第一个参数
就是写明要对哪个cf进行操作变更。
  
  详细的应用过程如下：
     首先是检查传入的VersionEdit集合 edit_list
  显然，如果我们传入的cfd 参数为空，唯一的可能就是要添加一个cf。因此我们可以看到相关的代码都会对这个进行检查
  ```c++
if (column_family_data == nullptr) {
      assert(num_edits == 1);
      assert(edit_list[0]->is_column_family_add_);
      assert(new_cf_options != nullptr);
  }
```
  对于每个后台线程（flush和compaction）它们总是在执行任务，参考wal组提交机制
我们可以利用类似的思想来提高效率
```c++
   ManifestWriter w(mu, column_family_data, edit_list);
   manifest_writers_.push(&w);
   // 如果不是leader，那么就等待Leader处理完成
   while(!w.done && &w != manifest_writers_.front()) {
     w.cv.Wait();
   }
   if (w.done) {
     return w.status;
   }
   // Leader 执行下面的逻辑
```
   可以看到对于每个线程执行Apply VersionEdit操作，我们首先是把对应的ve都封装到一个
   ManifestWriter任务中去，然后放入到全局的manifest_writers_列表中去，
   如果队列中没有其他的任务，那么当前的任务就是leader, 它会负责ve的写入操作。
   而如果我们的线程是follower，那么这里只需要简单的等待leader完成相应的任务。然后leader会通知follower
   任务完成.
   
为了方便理解，这里要梳理一下基本的数据结构：
   1. manifest_writers_ 是我们写线程要进行写数据的结合
   2. 对于每个写线程，它都通过ve的集合来表示

所以leader线程的处理过程如下：
   ```c++
    ManifestWriter* last_writer = &w;  // leader
    if (w.edit_list.front->IsColumnFamilyManipulation()) {
      LogAndApplyCFHelper(w.edit_list.front());
      batch_edits.push_back(w.edit_list.front());
    } else {
      v = new Version(column_family_data, this, current_version_number++);
      builder_guard.reset(new BaseReferencedVersionBuilder(column_family_data));
      auto* builder = builder_guard->version_builder();
      // 依次遍历每个writer
      for (const auto& writer : manifest_writers_) {
        if (writer->edit_list.front()->IsColumnFamilyManipulation() ||
            writer->cfd->GetID() != column_family_data->GetID()) {
          break;
        }
        // 依次遍历每个write要写入的ve数据
        last_writer = writer;
        for (const auto& edit : writer->edit_list) {
          LogAndApplyHelper(column_family_data, builder, v, edit, mu);
          batch_edits.push_back(edit);
        }
      }
      builder->SaveTo(v->storage_info());
    }
```
   在上面的过程中，我们可以看到我们依次把不同的writer数据聚合到leader来一个个的处理，那么这里有一个问题
不同的任务在执行这些ve操作的时候，执行顺序会影响正确性吗？
   答案是： 不会影响正确性.
首先因为compaction执行的时候，不允许有交集。其实我们后台执行的这些compaction也都是append only的方式来写数据的。
在这个过程中，我们只会把没有快照引用的垃圾数据在compaction的过程中删除， 然后生成新的文件。详细的可以参考我们的快照模块。
   在上面的应用过程中，有一个helper函数，这个函数的主要作用就让对应的builder应用上我们的增量操作
  ```c++
     void VersionSet::LogAndApplyHelper(ColumnFamilyData* cfd,
                                        VersionBuilder* builder, Version* v,
                                        VersionEdit* edit, InstrumentedMutex* mu) {
  //
  if (!edit->has_prev_log_number) {
    edit->SetPrevLogNumber(prev_log_number_);
  }
  edit->SetNextFile(next_file_number_.load());
  edit->SetLastSequence(last_sequence_);
  builder->Apply(edit);
  //
}
```
  这个helper函数的作用非常简单，就是设置一下这个ve的一些上下文，然后把这个ve应用到builder中去
既然都是应用到builder中去，通过上面的代码片段，我们可以看到， 这个builder其实也是通过对应的cf来初始化的
然后通过cf来获取对应的cf buidler，然后拿着当前cf的最新的version来应用一个个的ve.

为了方便理解，我这里把重要的逻辑通过下面的伪代码来再次描述一遍：
```c++
   // 1. 通过cfd,来初始化一个版本，引用cfd的最新版本的数据
   v = new Version(column_family_data, this, current_version_number_++);
   builder_guard.reset(new BaseReferencedVersionBuilder(column_family_data));
   auto* builder = builder_guard->version_builder();
   // 2. 把所有其他线程的write都一一聚合到对应的buider中
   for (const auto& edit : writer->edit_list) {
     LogAndApplyHelper(column_family_data, builder, v, edit, mu);
   }
   // 3. 把缓存在builder中的所有的ve，一个个的保存到当前的version中去
   // 如函数名称那样，是把builder中保存的一个个的添加到现有的version中去
   builder->SaveTo(v->storage_info());
```

#### 如何把缓存的ve数据一个个的添加到现有的版本中去的
   如之前的分析，所有的新增的ve都保存在builder中，显然就下面的rep_中
  ```c++
void VersionBuilder::SaveTo(VersionStorageInfo* vstorage, Status* status) {
  rep_->SaveTo(vstorage, status);
}
```
   那么这个rep_内部对象，有啥重要的数据结构呢？

  1. base_vstorage_  这个对象就是指向builder刚刚创建时的cfd的最新的version
  
在这个方法中还有一个VersionStorageInfo* 对象，要深入的理解，必须明白这个vstorage和Rep中的base_storage_对象有啥区别
。通过上面的代码调用我们知道，传入的vstorage对象是当前cfd对应的最新的verison中存储的数据。

在install之前，第一件事情，就是校验LSM数据的一致性. 校验数据的一致性，这块主要是在kv分离的模块中添加的，
在之前的版本中，是没有这一步的。
   因为我们要跟踪blob文件和sst之前的关联，所以定义数据结构
```c++
  using ExpectedLinkedSsts =
     std::unordered_map<uint64_t, BlobFileMetaData::LinkedSsts>;
     
  // 对于LinkedSsts定义如下
  using LinkedSsts = std::unordered_set<uint64_t>;
```
  我们就是通过ExpectedLinkedSsts这个结构来追踪一个blob文件跟多少个sst文件相互关联. 显然
一个sst中的key可能会关联不同的blob文件，同样一个blob文件中的value，可能来自不同sst的引用。


  

